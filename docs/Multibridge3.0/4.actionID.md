---
sidebar_label: '4. Bridge Action ID'
sidebar_position: 4
image: /cover-image.png
description: The Most Powerful Multi-Chain NFT Bridge
---

# Bridge Action ID

## History of the concept

The concept of asset duplication prevention was present in various contexts before the emergence of Web3. In traditional finance and accounting, preventing asset duplication has long been a crucial principle to ensure the accuracy of financial records.

However, the very concept of blockchain is centered around the tools preventing users' use of voluntary asset minting or duplicating. Every chain begins with a genesis state, where several accounts have some assets. Every blockchain's following history is a history of inputs and outputs carefully validated by the nodes ensuring everybody plays by the rules.

In the context of Bitcoin, for example, the prevention of asset duplication is primarily achieved through a distributed ledger. Each transaction is verified and recorded by a network of nodes. Each transaction includes inputs and outputs associated with unique digital signatures. The combination of these inputs and outputs and their associated digital signatures are used to create a unique transaction ID.

Once a transaction is verified and recorded on the blockchain, it cannot be modified or duplicated. It means that each Bitcoin unit can only be owned by one person or entity at a time. The network would immediately detect any attempt to duplicate or counterfeit the Bitcoin.
In addition to the blockchain, Bitcoin relies on a consensus mechanism called proof-of-work to prevent asset duplication. This mechanism requires nodes on the network to perform complex calculations to verify transactions and earn newly minted Bitcoin units. It makes it computationally expensive to attempt to create fake transactions or duplicate Bitcoin units, as it would require enormous computing power.

## XP.NETWORK implementation

Following the principle of asset duplication prevention as a part of the multilayer security system, we ensure the assets are available to the users in one place at a time only. For example, if an NFT minted on Ethereum is bridged to MultiversX, the token on Ethereum is locked in the bridge contract. The only NFT available to the users for transferring, trading, staking, etc., is on MultiversX.

Because different blockchains are asynchronous and ignorant of each other's existence, the bridge fills the gap by emitting its transaction or `actionIds` in the smart contracts orchestrating the work of token contracts and the off-chain oracle validators.

The bridge contract keeps track of all the outgoing and incoming transactions. The outgoing transactions are incremented (`actionId++;`) every time users interact with the contract by calling its functions. The external transactions are stored in a mapping ensuring `O(1)` access complexity to prevent duplicate transactions.

## Implementation v1.0

\When bridging between 2 chains, action ID is straightforward to implement. However, when 30+ chains are involved, the chance of collision grows, exponentially increasing the possibility of broken transactions and stuck assets.

The initial implementation of the action ID transformation to make each "foreign" action ID unique looked like this:

```ts
// Szudzik elegant pair
function pairAction(x: bigint, y: bigint): bigint {
    return x >= y ? x * x + x + y : x + y * y;
}

actionId = new BigNumber(
    pairAction(BigInt(act), BigInt(emitter.chainNonce)).toString()
);
```

## Implementation v2.0

Do substantially decrease the probability of foreign action ID collision the formula was transformed to:

```ts
import { ethers } from "ethers";

type numstring = number | string;

const actionIdDigest = (
    fromChain: numstring,
    toChain: numstring,
    originActionId: numstring
) => {
    const unhashed = `${fromChain}-${toChain}-${originActionId}`
    return ethers.keccak256(
        Buffer.from(unhashed, 'hex')
    )
}

// Example
const result = actionIdDigest(
    4,  // BSC
    7,  // Polygon
    215 // actionId on BSC
)

console.log(result);
// Output:
// 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
```