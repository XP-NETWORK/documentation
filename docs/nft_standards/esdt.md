---
sidebar_label: '5. ESDT'
sidebar_position: 5
image: /cover-image.png
description: The Most Powerful Multi-Chain NFT bridge
---

# ESDT

## Abstract

In contrast with EVM token standards such as ERC-20, ERC-721, and ERC-1155, where tokens are minted and managed inside a smart contract, Elrond tokens are minted in an ESDT, which stands for Elrond Standard Digital Tokens, which provides for speed and scalability compared to EGLD, the native token of Elrond.

Solving Vitalik Buterin's Trilema, Elrond sharded its blockchain into Metachain and three shards. ESDT handles the asset propagation into shards, so the user does not have to worry about deploying contracts on each one of them.

Like in EVM compatible chains, the major difference between fungible and non-fungible tokens is that the last has additional metadata describing the unique features of the token and bears a link to the digital asset - an image, a video, or a sound. However, in Elrond, there's no need for contracts implementing multiple standards. Everything happens inside ESDT.

## Issuing steps

Before an NFT can be minted on Elrond, several steps must be taken, each one of them being a submitted and signed transaction:
1. The ESDT token must be created
2. The roles (Minting, Burning, etc.) must be set to designated accounts
3. Minting NFTs or SFTs
4. Transferring the tokens to the new owner if required

### Existing Roles: 

### For NFT:

- `ESDTRoleNFTCreate` : this role allows one to create a new NFT
- `ESDTRoleNFTBurn` : this role allows one to burn quantity of a specific NFT
- `ESDTRoleNFTUpdateAttributes` : this role allows one to change the attributes of a specific NFT
- `ESDTRoleNFTAddURI` : this role allows one add URIs for a specific NFT
- `ESDTTransferRole` : this role enables transfer only to specified addresses. The owner of the NFT and the address with the ESDTTransferRole should be located on the same shard. The addresses with the transfer role can transfer anywhere.

### For SFT:

- `ESDTRoleNFTCreate` : this role allows one to create a new SFT
- `ESDTRoleNFTBurn` : this role allows one to burn quantity of a specific SFT
- `ESDTRoleNFTAddQuantity` : this role allows one to add quantity of a specific SFT
- `ESDTTransferRole` : this role enables transfer only to specified addresses. The owner of the SFT and the address with the ESDTTransferRole should be located on the same shard. The addresses with the transfer role can transfer anywhere.

## ESDT Names

The identifier of ESDT consists of two parts. The first part should be provided by the deployer. It must not contain spaces, dashes, or any other punctuation. The second part is randomly generated by the network, which prevents name collisions even if someone names an ESDT just like you did.
For example, if you named your collection MyCollection, you will get something like MYCOLLECTION-3e4r5t.

## Code Snippets

```ts
import { ApiNetworkProvider } from '@elrondnetwork/erdjs-network-providers';

export const getProvider = () => {

  //    Testnet Setup
  return new ApiNetworkProvider('https://devnet-api.elrond.com', {
    timeout: 10000,
  });

  //    Mainnet setup
  return new ApiNetworkProvider('https://api.elrond.com', {
    timeout: 10000,
  });
};
```

### Getting the transaction signer

```ts
import { UserSigner } from '@elrondnetwork/erdjs';
import {config} from 'dotenv';
config();

// Make sure to replace line breaks with '\n'
const signer = UserSigner.fromPem(process.env.pem!);
```

```ts
import {
  Account,
  Address,
  AddressValue,
  Balance,
  BigUIntValue,
  BytesValue,
  ContractFunction,
  Egld,
  ExtensionProvider,
  GasLimit,
  ISigner,
  NetworkConfig,
  ProxyProvider,
  TokenIdentifierValue,
  Transaction,
  TransactionHash,
  TransactionPayload,
  U64Value,
  WalletConnectProvider,
} from "@elrondnetwork/erdjs";
```

### Creating a new ESDT

```ts
  const unsignedIssueESDTNft = (
    name: string,
    ticker: string,
    canFreeze: boolean | undefined,
    canWipe: boolean | undefined,
    canTransferNFTCreateRole: boolean | undefined
  ) => {
    let baseArgs = TransactionPayload.contractCall()
      .setFunction(new ContractFunction("issueNonFungible"))
      .addArg(new TokenIdentifierValue(Buffer.from(name, "utf-8")))
      .addArg(new TokenIdentifierValue(Buffer.from(ticker, "utf-8")));

    if (canFreeze !== undefined) {
      baseArgs = baseArgs
        .addArg(new BytesValue(Buffer.from("canFreeze", "ascii")))
        .addArg(
          new BytesValue(Buffer.from(canFreeze ? "true" : "false", "ascii"))
        );
    }
    if (canWipe !== undefined) {
      baseArgs = baseArgs
        .addArg(new BytesValue(Buffer.from("canWipe", "ascii")))
        .addArg(
          new BytesValue(Buffer.from(canWipe ? "true" : "false", "ascii"))
        );
    }
    if (canTransferNFTCreateRole !== undefined) {
      baseArgs = baseArgs
        .addArg(
          new BytesValue(Buffer.from("canTransferNFTCreateRole", "ascii"))
        )
        .addArg(
          new BytesValue(
            Buffer.from(canTransferNFTCreateRole ? "true" : "false", "ascii")
          )
        );
    }

    return new Transaction({
      receiver: ESDT_ISSUE_ADDR,
      value: new Balance(
        Egld.getToken(),
        Egld.getNonce(),
        new BigNumber(ESDT_ISSUE_COST.toString())
      ),
      gasLimit: new GasLimit(60000000),
      data: baseArgs.build(),
    });
  };
```

### Setting roles:

```ts
  const unsignedSetESDTRoles = (
    token: string,
    target: Address,
    roles: ESDTRole[]
  ) => {
    let baseArgs = TransactionPayload.contractCall()
      .setFunction(new ContractFunction("setSpecialRole"))
      .addArg(new TokenIdentifierValue(Buffer.from(token)))
      .addArg(new AddressValue(target));

    for (const role of roles) {
      baseArgs = baseArgs.addArg(new BytesValue(Buffer.from(role, "utf-8")));
    }

    return new Transaction({
      receiver: ESDT_ISSUE_ADDR,
      gasLimit: new GasLimit(70000000), // TODO: auto derive
      data: baseArgs.build(),
    });
  };
```