---
sidebar_label: '1. OTS (One-Time signature)'
sidebar_position: 1
image: /cover-image.png
description: The Most Powerful Multi-Chain NFT bridge
---

# OTS (One-Time signature)

The name of the algorithm type implies that it can be securely used only once. The reason is that **every time a message is signed, a part of the private key is being exposed**. If used multiple times, all the private key parts will eventually become exposed and, therefore, compromised. However, OTS algorithms were developed in the 1970s, and if properly used, they were safe enough for the time.

Specialists distinguish two most widely known types of digital signatures:

## 1.1 LOTS (Lamport One-Time Signature)[^1]

In 1979 Leslie Lamport suggested an improvement of M.Rabin's digital signature algorithm (1978) and introduced the concept of OTS that can be built from any one-way function, for example, a hash function. Lamport defined the one-way function as easy to compute but hard to revert. By contrast, with **RSA** (an algorithm suggested in 1977 by Ron **R**ivers, Adi **S**hamir, and Leonard **A**dleman), LOTS' hash is longer and, thus, believed to be more secure.

Since OTS belongs to Asymmetric Cryptography, the first step in using the algorithm is Public & private key pair generation.

### 1.1.1 LOTS Private Key Generation

The length of the private key depends on the length of the hash function used to generate it. If a hashing algorithm has length **$n$** then $2n$ random secret values must be generated to form the private key:

$$
PrivateKey = X_0 || Y_0 ~||~ X_1 || Y_1 ~||...||~ X_{n-1} || Y_{n-1}
$$

### 1.1.2 LOTS Public Key Generation

The Public Key is generated by concatinating the hashed values of the generated secrets.

$$
PublicKey = hash(X_0) || hash(Y_0) ~||~ hash(X_1) || hash(Y_1) ~||...||~ hash(X_{n-1}) || hash(Y_{n-1})
$$

### 1.1.3 Signature Generation

Before signing, a hash is generated from the message or the transaction. This resulting hash can be represented as a bit string $|~0~|~1~|~1~|~0~|~1~|~0~|~0~|~...~|~0~|$   To sign a message we must publish one of the keys from the pair depending on whether the corresponding bit is $|~0~|$ or $|~1~|$. The final signature (SIG) 

$$
|~0~| ~=>~ SK(~X_0~ || ~Y_0~) ~=>~ SIG_0(X_0) \\
|~1~| ~=>~ SK(~X_1~ || ~Y_1~) ~=>~ SIG_1(Y_0) \\
... \\
|0| => SK(X_{n-1} || Y_{n-1}) => SIG_{n-1}(X_{n-1})
$$

Since both the message and the signature are public an adversary can reconstruct a part, potentially, one half of the secret key (SK). If the key is reused, every time where there will be a different bit value ($1$ instead of $0$ or vice versa) the second part of the secret key will be exposed.

$$
bit_0 ~ is ~|~0~| ~ and ~ SIG_0(X_0) ~=>~ SK(~X_0~ || ~?_0~)  \\
bit_1 |~1~| ~ and ~ SIG_1(Y_1) ~=>~ SK(~?_1~ || ~Y_1~)  \\
... \\
bit_{n-1} ~ |0| ~ and ~ SIG_{n-1}(X_{n-1}) => SK(X_{n-1} || ?_{n-1})
$$

### 1.1.4 LOTS Signature Verification

Since the public key is a compilation of hashes of the $(X||Y)$ values of the secret key, we can run the signature trough the same hashing algorithm and if the hashes match, the signature is valid.

$$
hash(SIG_0(X_0)) == hash(X_0) || hash(Y_0) \\
hash(SIG_1(Y_1)) == hash(X_1) || hash(Y_1) \\
... \\
hash(SIG_{n-1}(X_{n-1})) == hash(X_{n-1}) || hash(Y_{n-1})
$$

## 1.2 WOTS (Winternitz One-Time Signature)[^2]

This page section is a work in progress...

[^1]: https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Constructing-Digital-Signatures-from-a-One-Way-Function.pdf

[^2]: https://huelsing.net/wordpress/wp-content/uploads/2013/05/wotsspr.pdf